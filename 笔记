实现克隆 Cloneable
实现对象数组比较 Comparable
实现集合数组比较 Comparator

线程:调用start()方法来唤醒并开始执行目标对象的run方法,
       停止线程:stop()不推荐
       JDK推荐用Interrupt中断线程,但是使用Interrupt是有限制的:
       对线程interrupt是对线程处在sleep,wait,join状态的时候起作用
wait notify notifyAll

Thread.yield( )方法：
使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，
也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了
使用yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的

线程池 Executor启动 特性：减少了创建和销毁线程的次数，每个工作线程都可以被重复利用
                            根据系统承受能力，调整线程池中线程数目，每个线程需1mb内存

这个是发生在编译时的。方法重载也被称为编译时多态，
因为编译器可以根据参数的类型来选择使用哪个方法。

这个是在运行时发生的。方法覆盖被称为运行时多态，
因为在编译期编译器不知道并且没法知道该去调用哪个方法。JVM会在代码运行的时候做出决定

泛型（又称类型检验）：这个是发生在编译期的。编译器负责检查程序中类型的正确性，然后把
使用了泛型的代码翻译或者重写成可以执行在当前JVM上的非泛型代码。这个技术被称为“类型擦除“。
换句话来说，编译器会擦除所有在尖括号里的类型信息，来保证和版本1.4.0或者更早版本的JRE的兼容性。